{"name":"Filbert","tagline":"A BERT serializer and BERT-RPC client for .Net, written in F#","body":"Filbert is a simple **BERT** serializer and **BERT-RPC** client for .Net, written in F#.\r\n\r\n### What is BERT?\r\n\r\n[BERT] (http://bert-rpc.org/) is a flexible binary serialization format using the same encoding format as Erlang's [external term format] (http://erlang.org/doc/apps/erts/erl_ext_dist.html) but supports only the following data types:\r\n\r\n* **SMALL_INTEGER_EXT** (tag 97) : unsigned 8-bit integer.\r\n* **INTEGER_EXT** (tag 98) : signed 32-bit integer in big-endian format (MSB first).\r\n* **FLOAT_EXT** (tag 99) : a float stored in scientific string format, e.g. .ToString(\"e20\").\r\n* **ATOM_EXT** (tag 100) : an Erlang atom, the maximum allowed length for atom is 255.\r\n* **SMALL_TUPLE_EXT** (tag 104) : a tuple with up to 255 elements.\r\n* **LARGE_TUPLE_EXT** (tag 105) : same as SMALL_TUPLE_EXT but supports up to 4294967295 (uint.MaxValue) elements.\r\n* **NIL_EXT** (tag 106) : represents an empty list.\r\n* **STRING_EXT** (tag 107) : string does NOT have a corresponding Erlang representation, but is an optimization for sending lists of bytes, the maximum number of bytes in the string is 65534.\r\n* **LIST_EXT** (tag 108) : a list of elements of any type specified in this list, supports up to 4294967295 elements. For the sake of simplicity, __Filbert__ does not support improper lists ([a|b]) right now.\r\n* **BINARY_EXT** (tag 109) : supports up to 4294967295 bytes.\r\n* **SMALL_BIG_EXT** (tag 110) : big integer up to +/- 255*256^254.\r\n* **LARGE_BIG_EXT** (tag 111) : big integer up to +/- 4294967295*256^4294967294!\r\n\r\nIn addition, BERT also specifies a number of complex types as tuples whose first item is the atom **bert**:\r\n* **nil** : { bert, nil }, the equivalent of null/nil in other languages. (Erlang associated the primitive __nil__ with the empty array [] only)\r\n* **boolean** : { bert, true } or { bert, false } for __true__ and __false__ respectively.\r\n* **dictionary** : { bert, dict, [{name, <<\"Yan\">>}, {nick, theburningmonk}] }, a dictionary is represented as a tuple with 3 items - the atoms __bert__ and __dict__ followed by a list of 2 item tuples each representing a key-value pair.\r\n* **time** : { bert, time, 1255, 295581, 446228 }, equals to 1255 megaseconds (millions of secons) + 295581 seconds + 446228 microseconds (millionths of a second, or 10 ticks) since the Unix Epoch time (1970 Jan 1st).\r\n\r\n### Encoding/Decoding\r\n\r\n`F#`\r\n\r\n    let mysterWord = [| 131uy; 107uy; 0uy; 8uy; 104uy; 97uy; 122uy; 101uy; 108uy; 110uy; 117uy; 116uy |]\r\n    let bert = Dictionary(Map.ofList [(Atom \"Filbert\", Atom \"means\"); (ByteList mysterWord, Atom \"!\")])    \r\n\r\n    // encode this BERT\r\n    use memStream = new MemoryStream()\r\n    Filbert.Encoder.encode bert memStream\r\n\r\n    // now decode it\r\n    memStream.Position <- 0L\r\n    let bert' = Filbert.Decoder.decode memStream\r\n\r\nThe full example is available in the F# example project [here](https://github.com/theburningmonk/Filbert/blob/master/Filbert.Example/Program.fs).\r\n\r\n`C#`\r\n\r\n    // create a new BERT\r\n    var mysterWord = new byte[] { 131, 107, 0, 8, 104, 97, 122, 101, 108, 110, 117, 116 };\r\n    var dict = new Dictionary<Bert, Bert>\r\n    {\r\n        { Bert.NewAtom(\"Filbert\"), Bert.NewAtom(\"means\") },\r\n        { Bert.NewByteList(mysterWord), Bert.NewAtom(\"!\") }\r\n    };\r\n\r\n    // there's also a helper static method 'FromDict' which constructs a new Bert.Dictionary using\r\n    // a standard dictionary type\r\n    var bert = Bert.FromDict(dict);\r\n\r\n    using (var memStream = new MemoryStream())\r\n    {\r\n        // encode the BERT\r\n        Filbert.Encoder.encode(bert, memStream);\r\n    }\r\n\r\n    // now decode it\r\n    memStream.Position = 0;\r\n    var bertClone = Filbert.Decoder.decode(memStream);\r\n\r\nThe full example is available in the C# example project [here] (https://github.com/theburningmonk/Filbert/blob/master/Filbert.ExampleCs/Program.cs)\r\n\r\n### Making BERT-RPC Calls\r\n\r\nFor more information regarding how BERT-RPC works, please refer to the [BERT-RPC spec](http://bert-rpc.org/).\r\n\r\nSuppose there is a `nat` Erlang module running on the BERT-RPC server, which looks like this:\r\n\r\n    -module(nat).\r\n    -export([add/2]).\r\n\r\n    add(A, B) -> A + B.\r\n\r\n`F#`\r\n\r\n    let client = Filbert.Rpc.BertRpcClient.Start(serviceUrl, portNumber)\r\n\r\n    // synchronous example\r\n    let result = client.Call(\"nat\", \"add\", Integer 1, Integer 100) |> Async.RunSynchronously\r\n\r\n    // asynchronous example\r\n    async {\r\n        let! result = client.Call(\"nat\", \"add\", Integer 1, Integer 100)\r\n        ... // do something with the result, printf, etc.\r\n    }\r\n    |> Async.Start\r\n\r\nThe full example is available in the F# example project [here](https://github.com/theburningmonk/Filbert/blob/master/Filbert.Example/Program.fs).\r\n\r\n\r\n`C#`\r\n\r\n    var client = Filbert.Rpc.BertRpcClient.Start(serviceUrl, portNumber)\r\n\r\n    // synchronous example\r\n    var result = client.CallAsTask(\"nat\", \"add\", Bert.NewInteger(1), Bert.NewInteger(100))\r\n                       .Result;\r\n\r\n    // asynchronous example (provided that this is an async method)\r\n    var result2 = await client.CallAsTask(\"nat\", \"add\", Bert.NewInteger(1), Bert.NewInteger(100));\r\n\r\nThe full example is available in the C# example project [here](https://github.com/theburningmonk/Filbert/blob/master/Filbert.ExampleCs/Program.cs).\r\n\r\n### NuGet\r\n\r\nDownload and install **Filbert** using [NuGet](https://nuget.org/packages/Filbert).\r\n\r\n<a href=\"https://nuget.org/packages/Filbert\"><img src=\"http://theburningmonk.com/images/filbert-nuget-install.png\" alt=\"NuGet package\"/></a>\r\n\r\n### Updates\r\nFollow the official twitter account [@FilbertFs](https://twitter.com/FilbertFs) for updates!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}